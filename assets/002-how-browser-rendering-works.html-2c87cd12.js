import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as r,c as i,a as e,b as a,e as s,f as l}from"./app-952e403b.js";const p="/blog/assets/image/frontend/browser/002/1-webkitflow.png",c="/blog/assets/image/frontend/browser/002/2-dom-tree.png",d="/blog/assets/image/frontend/browser/002/3-html-parse.png",u="/blog/assets/image/frontend/browser/002/4-css-parse.png",g="/blog/assets/image/frontend/browser/002/5-render-tree.png",h={},k=l('<p>浏览器渲染主要是依靠浏览器内核也就是浏览器渲染引擎，它通过一系列的解析将 HTML 文档渲染在浏览器上。</p><h2 id="主要流程" tabindex="-1"><a class="header-anchor" href="#主要流程" aria-hidden="true">#</a> 主要流程</h2><p>渲染引擎会从网络层中获取将要渲染的文档，主要的工作流程如下：</p><figure><img src="'+p+`" alt="webkit-flow" tabindex="0" loading="lazy"><figcaption>webkit-flow</figcaption></figure><ol><li>首先浏览器会解析 HTML 文档，将 HTML 解析成 DOM 树；CSS 样式表也会在同时进行加载，生成样式规则；而 JavaScript 会通过 DOM API 和 CSSOM API 来操作 DOM Tree 和 Style Rules。</li><li>解析完成后，渲染引擎会通过 DOM Tree 和 Style Rules 创造 Render Tree，此时会计算各个 DOM 在浏览器上的具体坐标。</li><li>最后渲染引擎遍历整个 Render Tree，由 UI 后端层绘制。</li></ol><p>整个渲染过程一个渐进的过程。为了更好的用户体验，渲染引擎将尽快在屏幕上显示内容。在开始构件和渲染 Render Tree 之前，它不会等到所有 HTML 都被解析。在部分内容被渲染的同时，渲染引擎会继续向服务器请求剩下的内容。</p><h2 id="html-解析器" tabindex="-1"><a class="header-anchor" href="#html-解析器" aria-hidden="true">#</a> HTML 解析器</h2><p>HTML 解析器的作用是将 HTML 解析成 DOM 树：</p><div class="language-html line-numbers-mode" data-ext="html"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>
      Hello World
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>example.png<span class="token punctuation">&quot;</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="`+c+'" alt="dom tree" tabindex="0" loading="lazy"><figcaption>dom tree</figcaption></figure><p>HTML 解析算法包括两个阶段：</p><ol><li>标记化：词法分析，将输入解析为标记。HTML 标记包括开始标记、结束标记、属性名称和属性值。标记器识别 token，将它传递给树构造器，然后接受下一个字符以识别下一个标记，直到输入的结束。</li><li>树构建：构建成 DOM 树。</li></ol><figure><img src="'+d+'" alt="HTML 解析" tabindex="0" loading="lazy"><figcaption>HTML 解析</figcaption></figure><h2 id="css-解析器" tabindex="-1"><a class="header-anchor" href="#css-解析器" aria-hidden="true">#</a> CSS 解析器</h2><p>解析器都会将 CSS 文件解析成 StyleSheet 对象，且每个对象都包含 CSS 规则。CSS 规则对象则包含选择器和声明对象，以及其他与 CSS 语法对应的对象。</p><figure><img src="'+u+'" alt="css 解析器" tabindex="0" loading="lazy"><figcaption>css 解析器</figcaption></figure><h2 id="render-tree" tabindex="-1"><a class="header-anchor" href="#render-tree" aria-hidden="true">#</a> Render Tree</h2><p>在 DOM 树构建的同时，浏览器还会构建另一个树结构：呈现树。这是由可视化元素按照其显示顺序而组成的树，也是文档的可视化表示。它的作用是让您按照正确的顺序绘制内容。</p><p>Render Tree 和 DOM Tree 并不是一一对应的，非可视化的 DOM 元素不会插入呈现树中，例如 <code>head</code> 元素。如果元素的 <code>display</code> 属性值为 <code>none</code>，那么也不会显示在呈现树中（但是 <code>visibility</code> 属性值为 <code>hidden</code> 的元素仍会显示）。</p><figure><img src="'+g+'" alt="render tree" tabindex="0" loading="lazy"><figcaption>render tree</figcaption></figure><p>接下来浏览器需要做的就是计算样式，将每一个 Render 对象的可视化属性计算（根据一系列规则，如层叠性、选择器权重等）出来，但是在这个过程中，并不包含位置和大小信息。计算这些值的过程叫做布局或回流。</p><blockquote><p>关于回流和重绘在后面说。</p></blockquote><p>总之，到目前为止，渲染引擎已经经历了一系列的工作，可以将页面展示到浏览器上了。</p><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>',24),m={href:"https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/#The_order_of_processing_scripts_and_style_sheets",target:"_blank",rel:"noopener noreferrer"},f={href:"https://coolshell.cn/articles/9666.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://zh.wiki.hancel.org/wiki/JavaScript%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"},b={href:"https://zh.m.wikipedia.org/wiki/%E6%B5%8F%E8%A7%88%E5%99%A8%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"},v={href:"https://cloud.tencent.com/developer/article/1679313",target:"_blank",rel:"noopener noreferrer"};function w(M,S){const n=o("ExternalLinkIcon");return r(),i("div",null,[k,e("ol",null,[e("li",null,[e("a",m,[a("How Browsers Work: Behind the scenes of modern web browsers - HTML5 Rocks"),s(n)])]),e("li",null,[e("a",f,[a("浏览器的渲染原理简介"),s(n)])]),e("li",null,[e("a",_,[a("JavaScript引擎 - 维基百科"),s(n)])]),e("li",null,[e("a",b,[a("浏览器引擎 - 维基百科"),s(n)])]),e("li",null,[e("a",v,[a("浏览器内核及分类 - 腾讯云社区"),s(n)])])])])}const H=t(h,[["render",w],["__file","002-how-browser-rendering-works.html.vue"]]);export{H as default};
