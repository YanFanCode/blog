import{_ as t}from"./plugin-vue_export-helper-c27b6911.js";import{r as o,o as p,c as i,a as n,b as s,e,f as r}from"./app-9ee26c46.js";const c="/blog/assets/image/frontend/browser/003/v8-work-flow.webp",l="/blog/assets/image/frontend/browser/003/parser.svg",u={},d=r('<p>在 JavaScript 引擎中，V8 无疑是最流行的，Chrome 与 Node.js 都使用了 V8 引擎。</p><p>V8 由很多子模块构成，有几个核心模块：</p><ul><li>Parser：解析器，负责将 JavaScript 代码解析成抽象语法树（Abstract Syntax Tree, AST）；</li><li>Ignition：解释器（interpreter），负责将 AST 转换为字节码（Bytecode）并执行；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型；</li><li>TurboFan：编译器（compiler），利用 Ignition 所收集的信息，将字节码转换为优化的机器码；</li><li>Orinoco：垃圾回收（garbage collector），负责将程序不再需要的内存空间回收。</li></ul><p>下面这张图是 V8 现有的工作流程，非常重要，在后面阅读的时候可以翻上来看看。</p><figure><img src="'+c+'" alt="v8 工作流程" tabindex="0" loading="lazy"><figcaption>v8 工作流程</figcaption></figure><h2 id="parser" tabindex="-1"><a class="header-anchor" href="#parser" aria-hidden="true">#</a> Parser</h2><p>为了让 V8 能够理解 JavaScript 代码，必须先将源码通过 <strong>Parser</strong> 解析成抽象语法树——代表程序结构的一系列对象。然后抽象语法树会被 <strong>Ignition</strong> 编译成字节码。这两个阶段是 V8 引擎性能的关键。</p><p>下图是 Parser 的工作流程：</p><figure><img src="'+l+`" alt="parser" tabindex="0" loading="lazy"><figcaption>parser</figcaption></figure><p>整个流程分为两个阶段：词法分析和语法分析。</p><ul><li><strong>词法分析</strong>：scanner 从我们编写的 JavaScript 代码中生成一系列的 tokens。而 tokens 是由一个或多个具有单一语义的字符组成的块：字符串、标识符、运算符 <code>++</code> 等。</li><li><strong>语法分析</strong>：语法分析的输入就是词法分析的输出（即 tokens），输出是 AST 抽象语法树。当程序出现语法错误的时候，V8 会在语法分析阶段抛出异常。</li></ul><p>V8 为了提升 scanner 性能，又做了<strong>延迟解析</strong>（lazy parsing）的优化，一些不会用到函数并不会被马上编译，他们会被 PreParser 处理，当以后调用一个 <code>preparsed</code> 函数时，它会根据需要进行完全解析和编译。</p><h2 id="ignition" tabindex="-1"><a class="header-anchor" href="#ignition" aria-hidden="true">#</a> Ignition</h2><p>当 Parser 将代码解析成 AST 输入给 Ignition，Ignition 会将 AST 转换为字节码，分三种情况：</p><ul><li><p>函数只声明而不调用，则 Ignition 不会做任何操作；</p></li><li><p>如果函数只调用一次，则 Ignition 会解释字节码并执行。下面来看看例子；</p></li><li><p>如果函数调用多次，则 Ignition 会收集 TurboFan 优化所需的信息（比如函数参数的类型信息等）。</p></li></ul><p>下面来看看例子。</p><ol><li><p>只是声明函数 <code>add</code>，但是没有调用，则 Ignition 不会做任何转换。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li><li><p>声明后第一次调用 <code>add</code> 函数，Ignition 会把它编译成字节码执行。到这个时候，JavaScript 代码就已经执行完成了。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div></li><li><p>但是如果发现有<strong>热点函数</strong>（即一个函数被多次调用），Ignition 就会收集 <code>add</code> 函数的各种参数类型，为 TurboFan 的优化提供支持。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token comment">// 调用多次，标记成热点函数，收集各种信息</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div></li></ol><h2 id="turbofan" tabindex="-1"><a class="header-anchor" href="#turbofan" aria-hidden="true">#</a> TurboFan</h2><p>TurboFan 是一个编译器，可以将字节码编译为 CPU 可以直接执行的机器码。如果一个函数被多次调用，就会被标记为<strong>热点函数</strong>，那么就会经过 TurboFan 转换成优化的机器码，提高代码的执行性能。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">%</span><span class="token function">OptimizeFunctionOnNextCall</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>V8 的 <code>%OptimizeFunctionOnNextCall</code> 可以直接指定优化哪个函数，它根据上次调用的参数反馈优化 <code>add</code> 函数，很明显这次的反馈是整型数，所以 TurboFan 会根据参数是整型数进行优化直接生成机器码，下次函数调用直接调用优化好的机器码。</p><p>但是，机器码实际上也会被还原为字节码，这是因为如果后续执行函数的过程中，类型发生了变化（比如 <code>add</code> 函数原来执行的是 <code>number</code> 类型，后来执行变成了 <code>string</code> 类型），之前优化的机器码并不能正确的处理运算，就会逆向的转换成字节码。这个就是最上面那个图还有个 <code>Deoptimization</code> 的原因。</p><div class="language-javascript line-numbers-mode" data-ext="js"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;1&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>到此，V8 引擎的工作流程就已经完成了，但是还没有细究里面的执行细节，只是大概地了解了工作流程，等以后能完全看懂官方文章了再回来更新。</p></blockquote><h2 id="参考链接" tabindex="-1"><a class="header-anchor" href="#参考链接" aria-hidden="true">#</a> 参考链接</h2>`,25),k={href:"https://zh.wikipedia.org/wiki/JavaScript%E5%BC%95%E6%93%8E",target:"_blank",rel:"noopener noreferrer"},g={href:"https://blog.fundebug.com/2019/07/16/how-does-v8-work/",target:"_blank",rel:"noopener noreferrer"},v={href:"https://v8.dev/blog/scanner",target:"_blank",rel:"noopener noreferrer"},b={href:"https://v8.dev/blog/preparser",target:"_blank",rel:"noopener noreferrer"},m={href:"https://v8.dev/blog/ignition-interpreter",target:"_blank",rel:"noopener noreferrer"},h={href:"https://mp.weixin.qq.com/s/t__Jqzg1rbTlsCHXKMwh6A",target:"_blank",rel:"noopener noreferrer"};function f(_,x){const a=o("ExternalLinkIcon");return p(),i("div",null,[d,n("ol",null,[n("li",null,[n("a",k,[s("JavaScript 引擎 - 维基百科"),e(a)])]),n("li",null,[n("a",g,[s("JavaScript深入浅出第4课：V8引擎是如何工作的？"),e(a)])]),n("li",null,[n("a",v,[s("Blazingly fast parsing, part 1: optimizing the scanner"),e(a)])]),n("li",null,[n("a",b,[s("Blazingly fast parsing, part 2: lazy parsing · V8"),e(a)])]),n("li",null,[n("a",m,[s("Firing up the Ignition interpreter · V8"),e(a)])]),n("li",null,[n("a",h,[s("JavaScript 引擎 V8 执行流程概述"),e(a)])])])])}const w=t(u,[["render",f],["__file","003-V8.html.vue"]]);export{w as default};
